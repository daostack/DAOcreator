# DAOcreator Library

Utility library for configuring and deploying DAOstack DAOs.

## Why?

Configuring DAOstack DAOs can be confusing, and building a UI around that process is an even greater task. This library aims to implement all the necessary logic and data types (with sanitization) for the DAO's configuration and deployment process. This helps reduce the code needed for implementing new UI drastically, which will enable multiple DAOcreator experiences (Web UI, CLI, etc), without having to duplicate code.

To see an existing UI that uses this library, see the [@daostack/daocreator-ui-v1](../ui_v1/) package.

## How?

Documentation describing how to properly use this library will be added shortly. If you have any questions please reach out to anyone at dOrg (contact@dorg.tech). You can also look through the sample application linked above. [Here's a good place to start](../ui_v1/src/components/pages/DAOcreator/index.tsx).

## Project Architecture

### 3 Layers Of Data Types

We view the different data types in this project as if they are in 3 layers:

1. _Form Data_
2. _State Data_
3. _Dependency Data_

Data in each layer can flow in either direction, 1 <> 2 <> 3. We did this to avoid as many **run-time type related errors** as possible, and to decouple our user-friendly form data from the backing state & dependency data.

These type definitions can be found in:

1. `src/forms`
2. `src/state`
3. `src/dependency`

Confused? So were we, that's why we wrote this... here's a brief description of each layer:

- **Form Data**: Form classes that (1) take in user input data, (2) sanitized the data, and (3) convert it into a "state friendly" format. This layer also contains user friendly descriptions, which always remain outside of the state.

- **State Data**: The core state of the application.

- **Dependency Data**: These are types that are either provided by external dependencies, or created to make interacting with dependencies easier. These types should not be accessible to the project as a whole, they should be constrained to the dependency's module. This way we can easily change dependencies, and even add new ones without changing the top level interface!
